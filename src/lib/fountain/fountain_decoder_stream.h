#pragma once

#include "FountainDecoder.h"
#include "FountainMetadata.h"
#include <iostream>
#include <optional>
#include <string>

template <unsigned _bufferSize>  // 599
class fountain_decoder_stream
{
public:
	static const unsigned _headerSize = 2;

public:
	fountain_decoder_stream(unsigned dataSize)
	    : _decoder(dataSize, block_size())
	{
	}

	static fountain_decoder_stream create(const FountainMetadata& md)
	{
		return fountain_decoder_stream(md.file_size());
	}

	unsigned block_size() const
	{
		return _bufferSize - _headerSize;
	}

	size_t data_size() const
	{
		return _decoder.length();
	}

	bool good() const
	{
		return _decoder.good();
	}

	std::optional<std::vector<uint8_t>> decode()
	{
		// if we're full
		_buffIndex = 0;
		unsigned blockId = (unsigned)(_buffer[0]) << 8 | _buffer[1];
		return _decoder.decode(blockId, _buffer.data() + _headerSize, block_size());
	}

	// we need to track either:
	// 1. all packet header locations + current location in frame buffer to correlate
	// 2. current location in frame buffer to see if we're at a packet header location
	// 3. special case of #2, where we just roll forward every _bufferSize bytes?
	std::optional<std::vector<uint8_t>> write(const char* data, unsigned length)
	{
		while (length > 0 and good())
		{
			unsigned writeLen = std::min(length, (unsigned)(_buffer.size() - _buffIndex));
			uint8_t* dst = _buffer.data() + _buffIndex;
			std::copy(data, data + writeLen, dst);

			_buffIndex += writeLen;
			data += writeLen;
			length -= writeLen;

			if (_buffIndex == _buffer.size())
			{
				auto res = decode();
				if (res)
					return res;
			}
		}
		return std::nullopt;
	}

protected:
	FountainDecoder _decoder;
	std::array<uint8_t, _bufferSize> _buffer;
	unsigned _buffIndex = 0;
};
